# QD — Choice groups: client share view (trip-view.tsx)

One file changes: `client/src/pages/trip-view.tsx`. This adds the `choiceGroup` kind to `buildViewDayRenderItems`, a new `ChoiceGroupViewCard` component, and the optimistic choice selection state pattern (mirroring how `localSelections` works for variants).

---

## Overview of changes

1. Add `choiceGroup` kind to `ViewDayRenderItem` union and `buildViewDayRenderItems`
2. New `ChoiceGroupViewCard` component — renders two full segment cards with an OR separator and "Choose this option" buttons
3. Add `localChoices` state and `selectChoice` callback in `TripViewPage` — mirrors `localSelections` / `selectVariant`
4. Thread `localChoices`, `onSelectChoice`, and `lockedChoices` through `DayAccordion` → render loop
5. In approved mode (`trip.approvedVersionId` set): only render the `isChoiceSelected` segment, no bracket, no buttons
6. Update the trip total to exclude unchosen choice group segments

---

## Change 1: `ViewDayRenderItem` type and `buildViewDayRenderItems`

Find:
```typescript
type ViewDayRenderItem =
  | { kind: "segment"; segment: TripSegment }
  | { kind: "journey"; journeyId: string; legs: TripSegment[] }
  | { kind: "propertyGroup"; propertyGroupId: string; rooms: TripSegment[] };
```

Replace with:
```typescript
type ViewDayRenderItem =
  | { kind: "segment"; segment: TripSegment }
  | { kind: "journey"; journeyId: string; legs: TripSegment[] }
  | { kind: "propertyGroup"; propertyGroupId: string; rooms: TripSegment[] }
  | { kind: "choiceGroup"; choiceGroupId: string; options: TripSegment[] };
```

In `buildViewDayRenderItems`, add choice group collection alongside the existing journey and property group logic:

```typescript
function buildViewDayRenderItems(daySegments: TripSegment[], isApproved?: boolean): ViewDayRenderItem[] {
  const items: ViewDayRenderItem[] = [];
  const seenJourneyIds = new Set<string>();
  const seenPropertyGroupIds = new Set<string>();
  const seenChoiceGroupIds = new Set<string>();
  const journeyGroups = new Map<string, TripSegment[]>();
  const propertyGroups = new Map<string, TripSegment[]>();
  const choiceGroups = new Map<string, TripSegment[]>();

  for (const seg of daySegments) {
    if (seg.journeyId) {
      if (!journeyGroups.has(seg.journeyId)) journeyGroups.set(seg.journeyId, []);
      journeyGroups.get(seg.journeyId)!.push(seg);
    }
    if (seg.propertyGroupId && seg.type === "hotel") {
      if (!propertyGroups.has(seg.propertyGroupId)) propertyGroups.set(seg.propertyGroupId, []);
      propertyGroups.get(seg.propertyGroupId)!.push(seg);
    }
    if (seg.choiceGroupId) {
      if (!choiceGroups.has(seg.choiceGroupId)) choiceGroups.set(seg.choiceGroupId, []);
      choiceGroups.get(seg.choiceGroupId)!.push(seg);
    }
  }

  for (const seg of daySegments) {
    if (seg.journeyId && (journeyGroups.get(seg.journeyId)?.length ?? 0) > 1) {
      if (!seenJourneyIds.has(seg.journeyId)) {
        seenJourneyIds.add(seg.journeyId);
        const legs = journeyGroups.get(seg.journeyId)!;
        legs.sort((a, b) => ((a.metadata as any)?.legNumber || 0) - ((b.metadata as any)?.legNumber || 0));
        items.push({ kind: "journey", journeyId: seg.journeyId, legs });
      }
    } else if (seg.propertyGroupId && seg.type === "hotel" && (propertyGroups.get(seg.propertyGroupId)?.length ?? 0) > 1) {
      if (!seenPropertyGroupIds.has(seg.propertyGroupId)) {
        seenPropertyGroupIds.add(seg.propertyGroupId);
        items.push({ kind: "propertyGroup", propertyGroupId: seg.propertyGroupId, rooms: propertyGroups.get(seg.propertyGroupId)! });
      }
    } else if (seg.choiceGroupId && (choiceGroups.get(seg.choiceGroupId)?.length ?? 0) > 1) {
      if (!seenChoiceGroupIds.has(seg.choiceGroupId)) {
        seenChoiceGroupIds.add(seg.choiceGroupId);
        const options = choiceGroups.get(seg.choiceGroupId)!;
        options.sort((a, b) => a.sortOrder - b.sortOrder);

        if (isApproved) {
          // In approved mode: only emit the chosen segment as a plain segment item
          const chosen = options.find(o => o.isChoiceSelected) || options[0];
          items.push({ kind: "segment", segment: chosen });
        } else {
          items.push({ kind: "choiceGroup", choiceGroupId: seg.choiceGroupId, options });
        }
      }
    } else {
      // Skip unchosen segments that are part of a choice group in approved mode
      if (isApproved && seg.choiceGroupId && !seg.isChoiceSelected) continue;
      items.push({ kind: "segment", segment: seg });
    }
  }
  return items;
}
```

Note the `isApproved` parameter — pass it from `DayAccordion`.

---

## Change 2: `ChoiceGroupViewCard` component

Add after `PropertyGroupViewCard`, before `SegmentView`:

```tsx
function ChoiceGroupViewCard({
  options,
  showPricing,
  timeFormat = "24h",
  localChoices,
  onSelectChoice,
  lockedChoices,
  token,
  isApproved,
}: {
  options: TripSegment[];
  showPricing?: boolean;
  timeFormat?: "12h" | "24h";
  localChoices?: Record<string, string>; // choiceGroupId -> chosen segmentId
  onSelectChoice?: (choiceGroupId: string, segmentId: string) => void;
  lockedChoices?: Set<string>; // choiceGroupIds that are locked (submitted)
  token?: string | null;
  isApproved?: boolean;
}) {
  const choiceGroupId = options[0]?.choiceGroupId || "";
  const locallyChosenId = localChoices?.[choiceGroupId];
  const serverChosenId = options.find(o => o.isChoiceSelected)?.id;
  const chosenId = locallyChosenId || serverChosenId;
  const isLocked = lockedChoices?.has(choiceGroupId);
  const hasChosen = !!chosenId;

  return (
    <div
      className="rounded-lg border-2 border-dashed border-amber-300/50 dark:border-amber-700/30 overflow-hidden bg-amber-50/20 dark:bg-amber-950/5"
      data-testid={`view-choice-group-${choiceGroupId}`}
    >
      {/* Header */}
      <div className="flex items-center gap-2 px-4 pt-3 pb-1">
        <span className="text-[10px] font-semibold tracking-widest uppercase text-amber-600 dark:text-amber-400">
          Choose one option
        </span>
        {hasChosen && (
          <Badge variant="outline" className="text-[9px] border-emerald-300 text-emerald-600 dark:text-emerald-400 ml-auto">
            {isLocked ? "Choice submitted" : "Option selected"}
          </Badge>
        )}
      </div>

      {/* Option cards */}
      <div className="px-3 pb-3 space-y-0">
        {options.map((option, idx) => {
          const isChosen = chosenId === option.id;
          const isOtherChosen = hasChosen && !isChosen;

          return (
            <div key={option.id}>
              {idx > 0 && (
                <div className="flex items-center gap-2 my-2.5">
                  <div className="flex-1 border-t border-amber-200/50 dark:border-amber-800/30" />
                  <span className="text-[10px] font-bold text-amber-500 dark:text-amber-400 tracking-widest px-1">OR</span>
                  <div className="flex-1 border-t border-amber-200/50 dark:border-amber-800/30" />
                </div>
              )}

              <div
                className={`transition-all duration-300 ${isOtherChosen ? "opacity-40 pointer-events-none" : ""}`}
                data-testid={`view-choice-option-${option.id}`}
              >
                <SegmentView segment={option} showPricing={showPricing} timeFormat={timeFormat} />

                {/* Choose button — only show with a token (client) and not approved */}
                {token && !isApproved && onSelectChoice && (
                  <div className="flex justify-end mt-1.5 mb-0.5">
                    {isChosen ? (
                      <div className="flex items-center gap-1.5">
                        <span className="text-[11px] font-medium text-emerald-600 dark:text-emerald-400 flex items-center gap-1">
                          <Check className="w-3.5 h-3.5" />
                          {isLocked ? "Your choice" : "Selected"}
                        </span>
                        {!isLocked && (
                          <Button
                            variant="ghost"
                            size="sm"
                            className="h-6 text-[10px] text-muted-foreground ml-2"
                            onClick={() => onSelectChoice(choiceGroupId, "")}
                          >
                            Change
                          </Button>
                        )}
                      </div>
                    ) : (
                      <Button
                        variant="outline"
                        size="sm"
                        className="h-7 text-xs border-amber-300/60 hover:border-amber-400 hover:bg-amber-50 dark:hover:bg-amber-950/20"
                        onClick={() => onSelectChoice(choiceGroupId, option.id)}
                        disabled={isLocked}
                        data-testid={`button-choose-option-${option.id}`}
                      >
                        Choose this option
                      </Button>
                    )}
                  </div>
                )}

                {/* Advisor view: show which is chosen without buttons */}
                {!token && isChosen && (
                  <div className="flex justify-end mt-1">
                    <span className="text-[10px] text-emerald-600 dark:text-emerald-400 font-medium flex items-center gap-1">
                      <Check className="w-3 h-3" />
                      Client's choice
                    </span>
                  </div>
                )}
              </div>
            </div>
          );
        })}
      </div>
    </div>
  );
}
```

---

## Change 3: State and callback in `TripViewPage`

Add alongside the existing `localSelections` and `submitSuccess` state:

```typescript
const [localChoices, setLocalChoices] = useState<Record<string, string>>({});   // choiceGroupId -> segmentId
const [lockedChoices, setLockedChoices] = useState<Set<string>>(new Set());
```

**Initialize `localChoices` from server data.** In the existing `useEffect` that fetches variants and seeds `localSelections`, add choice group initialization after it:

```typescript
// Seed localChoices from server state
const allSegs = data.versions.flatMap(v => v.segments);
const choiceGroupMap = new Map<string, TripSegment[]>();
for (const seg of allSegs) {
  if (seg.choiceGroupId) {
    if (!choiceGroupMap.has(seg.choiceGroupId)) choiceGroupMap.set(seg.choiceGroupId, []);
    choiceGroupMap.get(seg.choiceGroupId)!.push(seg);
  }
}
const seedChoices: Record<string, string> = {};
for (const [cgId, segs] of choiceGroupMap.entries()) {
  const chosen = segs.find(s => s.isChoiceSelected);
  if (chosen) seedChoices[cgId] = chosen.id;
}
if (Object.keys(seedChoices).length > 0) {
  setLocalChoices(prev => ({ ...seedChoices, ...prev }));
}
```

**Add `selectChoice` callback** (mirrors `selectVariant` exactly):

```typescript
const selectChoice = useCallback(async (choiceGroupId: string, segmentId: string) => {
  // Optimistic update
  setLocalChoices(prev => {
    const next = { ...prev };
    if (segmentId) {
      next[choiceGroupId] = segmentId;
    } else {
      delete next[choiceGroupId]; // deselect
    }
    return next;
  });

  try {
    if (segmentId) {
      const url = token
        ? `/api/trips/${id}/segments/${segmentId}/choose?token=${token}`
        : `/api/trips/${id}/segments/${segmentId}/choose`;
      await fetch(url, { method: "POST", credentials: "include" });
    } else {
      // Deselect: PATCH all segments in group to clear isChoiceSelected
      // (handled server-side by passing empty segmentId — for now just clear locally)
    }
  } catch {
    // On error, revert optimistic update
    setLocalChoices(prev => {
      const next = { ...prev };
      delete next[choiceGroupId];
      return next;
    });
  }
}, [token, id]);
```

**Lock choices after submit** — when `submitSuccess` becomes true, lock all choice groups that have a selection:

```typescript
useEffect(() => {
  if (submitSuccess) {
    const locked = new Set<string>(Object.keys(localChoices));
    setLockedChoices(locked);
  }
}, [submitSuccess]);
```

Also seed `lockedChoices` from server state on load — if a segment in a choice group has `isChoiceSelected = true` and there's a submitted variant elsewhere (indicating the client already submitted), lock that choice group:

```typescript
// In the data initialization useEffect, after seeding localChoices:
if (data.trip.selectionsSubmittedAt) {
  const submittedCgIds = new Set<string>(
    Object.keys(seedChoices)
  );
  if (submittedCgIds.size > 0) setLockedChoices(submittedCgIds);
}
```

---

## Change 4: Thread through `DayAccordion`

Add to `DayAccordion` props interface:

```typescript
localChoices?: Record<string, string>;
onSelectChoice?: (choiceGroupId: string, segmentId: string) => void;
lockedChoices?: Set<string>;
isApproved?: boolean;
```

Pass them down in the `buildViewDayRenderItems` call and the render loop:

```typescript
// In DayAccordion, update the call:
{buildViewDayRenderItems(segments, isApproved).map((item) => {
  if (item.kind === "journey") { ... } // unchanged
  if (item.kind === "propertyGroup") { ... } // unchanged
  
  // ADD:
  if (item.kind === "choiceGroup") {
    return (
      <ChoiceGroupViewCard
        key={`choice-${item.choiceGroupId}`}
        options={item.options}
        showPricing={showPricing}
        timeFormat={timeFormat}
        localChoices={localChoices}
        onSelectChoice={onSelectChoice}
        lockedChoices={lockedChoices}
        token={token}
        isApproved={isApproved}
      />
    );
  }

  // existing segment rendering...
})}
```

Update the `DayAccordion` call site in `TripViewPage`:

```tsx
<DayAccordion
  key={dayNumber}
  dayNumber={dayNumber}
  segments={segments}
  dayDate={getDayDate(trip.startDate, dayNumber)}
  defaultOpen={dayNumber <= 2}
  showPricing={!!activeVersion?.showPricing}
  timeFormat={timeFormat}
  token={token}
  variantMap={variantMap}
  localSelections={localSelections}
  onSelectVariant={selectVariant}
  lockedSegments={lockedSegments}
  localChoices={localChoices}           // ADD
  onSelectChoice={selectChoice}         // ADD
  lockedChoices={lockedChoices}         // ADD
  isApproved={isApproved}              // ADD
/>
```

---

## Change 5: `isApproved` in `TripViewPage`

Add near the top of `TripViewPage`, after `activeVersion` is derived:

```typescript
const isApproved = !!(trip?.approvedVersionId && activeVersion && trip.approvedVersionId === activeVersion.id);
```

Pass `isApproved` to `DayAccordion` as shown above.

---

## Change 6: Trip total — exclude unchosen options

The trip total at the bottom of the view currently sums all segment costs. In approved mode, unchosen choice group segments should not count. Find:

```typescript
const subtotal = allSegments.reduce((sum, s) => sum + (s.cost || 0), 0);
```

Replace with:

```typescript
const subtotal = allSegments.reduce((sum, s) => {
  // Exclude unchosen choice group segments in approved mode
  if (isApproved && s.choiceGroupId && !s.isChoiceSelected) return sum;
  // Exclude unchosen in pre-approval if a local choice has been made for the group
  if (s.choiceGroupId && localChoices[s.choiceGroupId] && localChoices[s.choiceGroupId] !== s.id) return sum;
  return sum + (s.cost || 0);
}, 0);
```

This means: once the client clicks "Choose this option," the total updates immediately (optimistic) to reflect only the chosen option's cost, even before they submit.

---

## What the client sees

**Pre-selection (two hotels, neither chosen):**
```
╔═ Choose one option ══════════════════════════╗
║                                               ║
║  [The Beverly Hills Hotel card — full detail] ║
║                           [Choose this option]║
║                                               ║
║  ────────── OR ──────────                     ║
║                                               ║
║  [The Peninsula Beverly Hills — full detail]  ║
║                           [Choose this option]║
║                                               ║
╚═══════════════════════════════════════════════╝
```

**After choosing The Peninsula:**
```
╔═ Choose one option  ••• Option selected ══════╗
║                                               ║
║  [Beverly Hills Hotel card]    (faded 40%)    ║
║                                               ║
║  ────────── OR ──────────                     ║
║                                               ║
║  [The Peninsula card]                         ║
║       ✓ Selected           [Change]           ║
║                                               ║
╚═══════════════════════════════════════════════╝
```

**Approved itinerary — only The Peninsula visible, no bracket:**
```
[The Peninsula Beverly Hills card — full detail]
```